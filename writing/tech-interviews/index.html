<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="author" content="Benjamin Peterson">
<title>On Technical Interviews</title>
<link rel="icon" href="/static/img/favicon.png">
<link rel="stylesheet" href="/static/style/main.css">
</head>
<body>

<h1>On Technical Interviews</h1>
<span class="byline">by <a href="/">Benjamin Peterson</a><br>published 2014-10-31</span>

<p>I&rsquo;ve recently been doing a lot of interviews with American tech companies, small and large, for a position as a software engineer. In addition to the introvert-unfriendly experience of flying around the country in order to talk to strangers for a whole day, the content of many of the technical interviews has come to bother me.

<p>Allow me to sketch a hypothetical interview experience: Your first interviewer walks in, introduces themselves, and gives the question. The question almost surely involves large arrays of numbers as input. If the interviewer is feeling particularly creative, you might get a contrived story, too. (&ldquo;Imagine you are given an array of 100,000,000 floating point baseball scores between 0 and 10,000.&rdquo;) Thinking for a few seconds, you see there&rsquo;s an easy quadratic or cubic time algorithm. You&rsquo;ll code this bad algorithm up on a whiteboard with the sinking feeling that there&rsquo;s an &ldquo;obvious&rdquo;, more-efficient solution that you should have thought of the instant the problem was mentioned. This &ldquo;correct&rdquo; solution will involve some nontrivial data structure (probably one of the numerous balanced binary trees), and you&rsquo;ll arrive at it after some patient prodding from the interviewer. You might spend some quality time figuring out how to get indented code blocks to line up on a whiteboard. Then, if there&rsquo;s still time left in the interview, the parameters of the question may be altered, leaving you with a solution that may or not be able to be adequately extended. As the clock indicates the end of the interview, you wonder whether the interviewer would like to hear about your last interesting coding project. Alas, they scurry out and are replaced with a new interviewer and a new question about binary trees.

<h2>Binary Trees and Sorting</h2>
<p>Interview questions like the one imagined above can generally be characterized as easy <a href="https://en.wikipedia.org/wiki/ACM_International_Collegiate_Programming_Contest">programming competition</a> problems. I&rsquo;m not particularly bad at this type of problem, but it frustrates me to have all the skills I&rsquo;ve tried to cultivate as a software engineer reduced to mediocre algorithms and data structures brainteasers. Rather than holistic evaluations of my programming ability, many technical interview problems feel like they were lifted off the exam for an algorithms class. That&rsquo;s odd for an industry where a formal university education is <a href="http://www.thielfellowship.org/">seen as unnecessary</a>. However, there are even <a href="http://courses.csail.mit.edu/iap/interview/materials.php">courses</a> to help people cram for the interview &ldquo;exam&rdquo;.

<p>I don&rsquo;t wish to to minimize the importance of algorithms and data structures in software engineering or label them irrelevant. They are an core skill of our craft&mdash;but only one of many. Other abilities such as API design, code review, debugging, and interpersonal skills are just as important. As such, it&rsquo;s clear that the weight given to questions about algorithms and data structures in most tech interviews is way out of proportion. It&rsquo;s akin to evaluating a writer solely by asking them to <a href="https://en.wikipedia.org/wiki/Sentence_diagram">diagram sentences</a> and recall the comma rules they learned in grade school. Generously, I would say knowing how to apply <a href="https://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a> has about the same practical use as understanding the difference between <code>fork()</code> and <code>vfork()</code>, but you are far more likely to be asked about the former in an interview. The tech industry closes its eyes, crosses its fingers, and hopes people who know the time complexity of Dijkstra&rsquo;s algorithm are the same people who can design beautiful APIs, write defensive code, and create comprehensive test suites. It&rsquo;s depressing to think how many perfectly competent engineers are being passed over because they didn&rsquo;t know the difference between pre-order and post-order tree traversal. (And this is, of course, merely in addition to those sidelined by the <a href="http://www.pnas.org/content/111/12/4403.abstract">usual</a> <a href="http://www.theroot.com/articles/culture/2014/05/black_college_grad_study_highlights_continuing_bias_in_hiring.html">biases</a>.)

<h2>Tradition and Incentives</h2>

<p>I would like to understand how the tech industry arrived at its current interview process. Unfortunately, I don&rsquo;t know much about the history of the software engineering interview. (If anyone knows of any work on this, please let me know.) At any rate, I suspect the modern Silicon Valley incarnation of the technical interview has been heavily influenced by Google&rsquo;s hiring practices, which have always emphasized algorithmic knowledge.

<p>Algorithms and data structures usually feature prominently in the university educations of aspiring programmers. At least in the American computer science curriculum, algorithms and data structures form the core classes with systems classes at the periphery. Thus, asking about algorithms in interviews favors younger engineers, especially from elite engineering schools. At the same time, it creates biases against older developers, who haven&rsquo;t had to think about treaps in a while. Then there is a feedback loop as engineers hired on their data structure chops begin interviewing the next generation of engineers.

<p>(As an aside, I&rsquo;ve always found it interesting that the computer science you are quizzed about in a tech interview is basically frozen in the 1980s. Nearly all algorithm interview questions can be solved with a handy copy of <a href="https://en.wikipedia.org/wiki/Introduction_to_Algorithms">CLRS</a>. CLRS is a perfectly good book, but theoretical computer science has progressed quite a bit since its publication in ways relevant to today&rsquo;s working programmer. For example, <a href="https://en.wikipedia.org/wiki/Smoothed_analysis">smoothed analysis</a> provides a better understanding of an algorithm&rsquo;s practical running time than traditional asymptotic analysis. <a href="https://en.wikipedia.org/wiki/Randomized_algorithm">Randomized algorithms</a> have become critical to modern distributed computing and data processing among other fields. Aside from basic probability questions, though, I&rsquo;ve never been asked about this exciting area in an interview.)
  
<p>The typical software engineer will be required to do several technical interviews a week. Interviews are not usually considered to be a particularly interesting part of the job, and engineers naturally work to minimize the effort expended on them. Another reason, therefore, for the prevalence of algorithmic questions is that they are easier for the interviewer. For these problems, there are definitely correct and incorrect answers. Different candidate&rsquo;s performance can be easily compared. The tech industry has a love of data and often ignores information that can&rsquo;t easily be evaluated numerically. (A notable exception to this is the infamous &ldquo;culture fit&rdquo; hiring criterion.) In contrast to algorithm questions, it&rsquo;s hard to turn the maintainability of someone&rsquo;s code into quantitative nuggets ideal for comparison.

<h2>Whiteboards</h2>

<p>The practice of conducting coding exercises on whiteboards embodies the disconnect between interviews and real-world software engineering. Indeed, all the time in my life spent writing code on whiteboards has been for interviews. The interview problem is usually stressful enough. Why must it also be solved in such an unnatural environment for a programmer to work? I tend to write code (and English) in a nonlinear fashion. This is nearly impossible to do on a whiteboard without ending up with many sloppy-looking arrows indicating the insertion of code at various points. The whiteboard makes the interview feel like a strange oral exam where you&rsquo;re not allowed to use any of the tools of your craft. I&rsquo;ve also been asked to write code using Google Docs, which is like doing arithmetic with Roman numerals.

<p>Of all the problems with the modern technical interview, the whiteboard is one of the easiest to eliminate. Candidates should be provided with a computer to program on or, even better, allowed to bring their own laptop in. Perhaps it concerns some that the candidate may be able to simply look up the solution to the question on Google and StackOverflow. If the answer to a certain question is easy to look up and use, that merely demonstrates the irrelevance of the problem to everyday software engineering. Consider a hypothetical situation where a programmer needs to solve some obnoxious &ldquo;traditional&rdquo; interview question like finding ascending sequences in an unsorted array of integers. In this (highly unlikely) situation, they would be doing their employer a disservice by not checking the web for an solution first before concocting one themselves. Most programmers don&rsquo;t spend their days gluing code snippets from the internet together, so surely there can be interview questions that are still &ldquo;challenging&rdquo; even with the web available. In fact, the space of possible questions is much richer. For example, with a computer at hand, it&rsquo;s perfectly reasonable to ask questions that require looking at documentation or cloning a Git repository.

<h2>No Easy Solutions</h2>
<p>So, what can be done? Interviews should attempt to capture a much more holistic view of a candidate&rsquo;s programming skills. There&rsquo;s already been movement in this area. For example, <a href="http://www.quora.com/What-is-the-engineering-interview-process-like-at-Stripe">interviews at Stripe</a> can include designing an API, fixing a bug in a popular open source library, or pair programming. Even the old algorithms and data structure questions are probably salvageable by refocusing on problems encountered in their real-world application. Off the top of my head, I can imagine interesting discussions starting from talking about why despite the more appealing asymptotic behavior of heapsort, quicksort is usually faster; how the naive implementation of binary search <a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html">is broken</a>; or the cache unfriendliness of trees.

<p>Of course, simply changing interview questions is not panacea. I expect engineers will have to devote more energy to engaging with candidates. Holistic interview questions are not as easy for the interviewer as algorithm questions; API design is definitely subjective in ways the running time of an algorithm is not. We must also ensure new interview questions do not create new axes of bias. For example, evaluating a candidate&rsquo;s open source contributions or doing code walkthroughs in lieu of a normal interview seems promising but is unfair to people who haven&rsquo;t been doing the <a href="http://www.ashedryden.com/blog/the-ethics-of-unpaid-labor-and-the-oss-community">unpaid labor</a> of open source.

<p>I certainly don&rsquo;t have nor do I expect there to be a magic bullet. After all, deciding whether to hire someone with just a few hours of contact of is extremely difficult. What I do know is that the tech industry needs do some experimenting to find out how the technical interview experience can become more valuable for both the employer and the candidate.

</body>
</html>
